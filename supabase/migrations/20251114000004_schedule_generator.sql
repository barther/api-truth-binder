-- =========================
-- Schedule Generator - Auto-populate with Incumbents
-- Creates schedule slots and expected assignments
-- =========================

BEGIN;

-- Function to generate schedule for a date range
CREATE OR REPLACE FUNCTION generate_schedule(
  start_date DATE,
  end_date DATE
) RETURNS TABLE(
  slots_created INTEGER,
  assignments_created INTEGER
) LANGUAGE plpgsql AS $$
DECLARE
  v_slots_created INTEGER := 0;
  v_assignments_created INTEGER := 0;
  v_current_date DATE;
  v_trick RECORD;
  v_slot_id BIGINT;
  v_dow SMALLINT;
  v_owner_id BIGINT;
BEGIN
  -- Loop through each date in range
  v_current_date := start_date;

  WHILE v_current_date <= end_date LOOP
    -- Get day of week (1=Monday, 7=Sunday)
    v_dow := EXTRACT(ISODOW FROM v_current_date)::SMALLINT;

    -- Loop through all active tricks
    FOR v_trick IN
      SELECT
        dt.id AS trick_id,
        dt.rest_day1,
        dt.rest_day2,
        s.start_local,
        s.duration_hours,
        s.tz
      FROM desk_tricks dt
      JOIN shifts s ON s.id = dt.shift_id
      WHERE dt.active = TRUE
    LOOP
      -- Calculate UTC start time
      -- This is simplified - in production would need proper timezone conversion
      DECLARE
        v_start_utc TIMESTAMPTZ;
      BEGIN
        v_start_utc := (v_current_date || ' ' || v_trick.start_local::TEXT)::TIMESTAMP AT TIME ZONE v_trick.tz;
      END;

      -- Create schedule slot (if doesn't exist)
      INSERT INTO schedule_slots (
        desk_trick_id,
        local_date,
        start_utc,
        duration_hours
      )
      VALUES (
        v_trick.trick_id,
        v_current_date,
        v_start_utc,
        v_trick.duration_hours
      )
      ON CONFLICT (desk_trick_id, local_date) DO NOTHING
      RETURNING id INTO v_slot_id;

      IF v_slot_id IS NOT NULL THEN
        v_slots_created := v_slots_created + 1;

        -- Check if this is a rest day for the incumbent
        IF v_dow NOT IN (v_trick.rest_day1, v_trick.rest_day2) THEN
          -- Not a rest day - assign incumbent if exists
          SELECT jo.employee_id INTO v_owner_id
          FROM job_ownerships jo
          WHERE jo.desk_trick_id = v_trick.trick_id
            AND jo.end_date IS NULL
          LIMIT 1;

          IF v_owner_id IS NOT NULL THEN
            -- Create assignment
            INSERT INTO assignments (
              schedule_slot_id,
              employee_id,
              role,
              source,
              pay_basis,
              decision_path,
              notes
            )
            VALUES (
              v_slot_id,
              v_owner_id,
              'PRIMARY',
              'INCUMBENT',
              'STRAIGHT_TIME',
              'Auto-generated: Incumbent on working day',
              'Generated by schedule generator'
            )
            ON CONFLICT DO NOTHING;

            v_assignments_created := v_assignments_created + 1;
          END IF;
        END IF;
        -- Rest days are left vacant for Relief/EB to fill
      END IF;
    END LOOP;

    v_current_date := v_current_date + INTERVAL '1 day';
  END LOOP;

  RETURN QUERY SELECT v_slots_created, v_assignments_created;
END;
$$;

COMMENT ON FUNCTION generate_schedule IS 'Auto-populate schedule with incumbents for date range. Leaves rest days vacant.';

-- Convenience function to generate next N days
CREATE OR REPLACE FUNCTION generate_schedule_days(days INTEGER DEFAULT 30)
RETURNS TABLE(
  slots_created INTEGER,
  assignments_created INTEGER
) LANGUAGE SQL AS $$
  SELECT * FROM generate_schedule(
    CURRENT_DATE,
    CURRENT_DATE + (days || ' days')::INTERVAL
  );
$$;

-- Convenience function to generate specific month
CREATE OR REPLACE FUNCTION generate_schedule_month(year INTEGER, month INTEGER)
RETURNS TABLE(
  slots_created INTEGER,
  assignments_created INTEGER
) LANGUAGE SQL AS $$
  SELECT * FROM generate_schedule(
    DATE_TRUNC('month', (year || '-' || month || '-01')::DATE),
    DATE_TRUNC('month', (year || '-' || month || '-01')::DATE) + INTERVAL '1 month' - INTERVAL '1 day'
  );
$$;

COMMIT;
